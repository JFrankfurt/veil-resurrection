type Market @entity {
  id: Bytes!
  question: String!
  outcomes: [Outcome!]! @derivedFrom(field: "market")
  amm: Bytes!
  endTime: BigInt!
  resolved: Boolean!
  winningOutcome: Int
  invalid: Boolean!
  totalVolume: BigInt!
  totalLiquidity: BigInt!
  createdAt: BigInt!
  createdTx: Bytes!
  trades: [Trade!]! @derivedFrom(field: "market")
  liquidityEvents: [LiquidityEvent!]! @derivedFrom(field: "market")
}

type Outcome @entity {
  "market address + outcome index"
  id: Bytes!
  market: Market!
  index: Int!
  name: String!
  token: Bytes!
  "Current price in 18 decimals (0 to 1e18)"
  price: BigInt!
  reserve: BigInt!
}

type Trade @entity {
  "tx hash + log index"
  id: Bytes!
  market: Market!
  user: Bytes!
  outcome: Int!
  isBuy: Boolean!
  collateralAmount: BigInt!
  tokenAmount: BigInt!
  timestamp: BigInt!
  txHash: Bytes!
}

type Position @entity {
  "user address + market address"
  id: Bytes!
  user: Bytes!
  market: Market!
  "Balance of each outcome token"
  balances: [BigInt!]!
  "Total cost basis for P&L calculation"
  totalCost: BigInt!
  lastUpdated: BigInt!
}

type LiquidityEvent @entity {
  id: Bytes!
  market: Market!
  provider: Bytes!
  isAdd: Boolean!
  collateralAmount: BigInt!
  lpTokens: BigInt!
  timestamp: BigInt!
  txHash: Bytes!
}

type ProtocolStats @entity {
  id: ID!
  totalMarkets: Int!
  totalVolume: BigInt!
  totalTrades: Int!
}
